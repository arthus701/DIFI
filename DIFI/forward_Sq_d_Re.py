# Autogenerated with SMOP 0.29
import datetime
import jd2000_dt
import getmut
import gg2gm_2010
import numpy as np
import design_SHA_Sq_i_Re_v2
import design_SHA_Sq_e_Re_v2


def forward_Sq_d_Re(r, theta, phi, t, f107, s):
    # [B_1,B_2] = forward_Sq_d_Re(r,theta,phi,t,f107,s)

    # Calculate the primary (1) and induced (2) Sq magnetic field from a model
    # in DIPOLE coordinates (parameterization of Sabaka et al., 2002).
    # The output values B_1 and B_2 are in SPHERICAL Coordinates

    # Inputs:
    #     r(:)                    radius [km]
    #     theta(:), phi(:)        geographic co-latitude, longitude [deg]
    #     t(:)                    time [MJD2000]
    #     f107(:)                 F10.7 index
    #     s is a structure with the following elements
    #         m_e_d_Re(:,:)           primary Sq model (REAL coefficients)
    #         m_i_d_Re(:,:)           secondary Sq model (REAL coefficients)
    #         nmax, mmax              max degree and order in dipole coord.
    #         p_vec(:)                diurnal wavenumbers
    #         s_vec(:)                seasonal wavenumbers
    #         theta_NGP               co-latitude of N. Geomagnetic Pole [deg]
    #         phi_NGP                 longitude of N. Geomagnetic Pole [deg]
    #         h                       altitude of Sq currents [km]
    #         N                       Woldf ratio of the F10.7 dependence

    # Dependendies :
    # - "gg2gm", "jd2000", "getmut"
    # - "design_SHA_Sq_i_Re" and "design_SHA_Sq_e_Re"

    # A. Chulliat, 2016-09-22
    # (from an earlier version dated 2011-04-23, with inputs from N. Olsen)

    # Translated to Python by A. Woods 2018-1-1

    # calculate radii in units of reference radius
    a = 6371.2
    rho = r / a
    rho_Sq = (a + s['h']) / a
    # convert to matrix if input parameter is scalar
    max_size = max(
        np.array(
            (
                [np.size(rho)],
                [np.size(theta)],
                [np.size(phi)],
                [np.size(t)],
            )
        )
    )
    if np.isscalar(rho) or len(rho) == 1:
        rho = np.multiply(rho, np.ones(max_size))

    if np.isscalar(theta) or len(theta) == 1:
        theta = np.multiply(theta, np.ones(max_size))

    if np.isscalar(phi) or len(phi) == 1:
        phi = np.multiply(phi, np.ones(max_size))

    if np.isscalar(t) or len(t) == 1:
        t = np.multiply(t, np.ones(max_size))

    if np.isscalar(f107) or len(f107) == 1:
        f107 = np.multiply(f107, np.ones(max_size))

    if (
        np.size(t) != np.size(rho)
        or np.size(t) != np.size(theta)
        or np.size(t) != np.size(phi)
        or np.size(t) != np.size(f107)
    ):
        print(
            np.size(t),
            np.size(rho),
            np.size(theta),
            np.size(phi),
            np.size(f107),
        )
        raise Exception(r"Variables must be of equal size (or scalars)")

    # calculate time in year (season) and MUT
    t_1 = [
        datetime.timedelta(int(t_iter), (t_iter - int(t_iter)) * 3600)
        + datetime.datetime(2000, 1, 1)
        for t_iter in t
    ]
    year = [t_iter.year for t_iter in t_1]
    ndays = np.zeros(np.size(year))
    for i in range(len(year)):
        ndays[i] = (
            datetime.datetime(year[i]+1, 1, 1)
            - datetime.datetime(year[i], 1, 1)
        ).days
    # list comprehension must be converted to ndarray
    t_season = np.array(
        [
            (t[i] - jd2000_dt.jd2000_dt(year[i], 1, 1, 0)) / ndays[i]
            for i in range(len(ndays))
        ]
    )
    # not inlcuded in HDGM version
    t_season = np.squeeze(t_season)
    t_mut = getmut.getmut(t, s['theta_NGP'], s['phi_NGP'])
    # calculate dipolar coordinates + matrix R

    theta_d, phi_d, R = gg2gm_2010.gg2gm_2010(theta, phi, get_R=True)

    # calculate number of coefficients and data
    N_nm = (
        s['mmax'] * (s['mmax'] + 2)
        + (s['nmax'] - s['mmax']) * (2 * s['mmax'] + 1)
    )
    N_sp = np.size(s['p_vec']) * np.size(s['s_vec'])
    N_coeff_nm = 2 * N_nm * N_sp
    if (
        np.size(s['m_e_d_Re'], 0) != N_nm
        or np.size(s['m_e_d_Re'], 1) != 2*N_sp
    ):
        print(
            np.size(s['m_e_d_Re'], 0),
            N_nm,
            np.size(s['m_e_d_Re'], 1),
            2*N_sp,
        )
        raise Exception(r"wrong number of model coefficients")

    m_e_d_Re = np.reshape(s['m_e_d_Re'], N_coeff_nm, order='F')
    m_i_d_Re = np.reshape(s['m_i_d_Re'], N_coeff_nm, order='F')
    N_data = np.size(theta, 0)

    # CASE #1: above Sq currents

    if (min(rho) > rho_Sq):
        # calculate design matrices
        A_r_i_d, A_theta_i_dd, A_phi_i_dd = \
            design_SHA_Sq_i_Re_v2.design_SHA_Sq_i_Re_v2(
                rho,
                theta_d,
                phi_d,
                t_season,
                t_mut,
                s['nmax'],
                s['mmax'],
                s['p_vec'],
                s['s_vec'],
            )
        # A_theta_i_d = np.zeros((N_coeff_nm, N_data))
        # A_phi_i_d = np.zeros((N_coeff_nm, N_data))
        # calculate magnetic field
        B_r_1_tmp = np.dot(m_e_d_Re, A_r_i_d)
        B_theta_1_tmp = np.dot(m_e_d_Re, A_theta_i_dd)
        B_phi_1_tmp = np.dot(m_e_d_Re, A_phi_i_dd)
        B_r_2_tmp = np.dot(m_i_d_Re, A_r_i_d)
        B_theta_2_tmp = np.dot(m_i_d_Re, A_theta_i_dd)
        B_phi_2_tmp = np.dot(m_i_d_Re.T, A_phi_i_dd)
    # CASE #2: below Sq currents
    elif (max(rho) < rho_Sq):
        # calculate design matrices
        A_r_i_d, A_theta_i_dd, A_phi_i_dd = \
            design_SHA_Sq_i_Re_v2.design_SHA_Sq_i_Re_v2(
                rho,
                theta_d,
                phi_d,
                t_season,
                t_mut,
                s['nmax'],
                s['mmax'],
                s['p_vec'],
                s['s_vec'],
            )
        A_r_e_d, A_theta_e_dd, A_phi_e_dd = \
            design_SHA_Sq_e_Re_v2.design_SHA_Sq_e_Re_v2(
                rho,
                theta_d,
                phi_d,
                t_season,
                t_mut,
                s['nmax'],
                s['mmax'],
                s['p_vec'],
                s['s_vec'],
            )
        # A_theta_i_d = np.zeros((N_coeff_nm, N_data))
        # A_phi_i_d = np.zeros((N_coeff_nm, N_data))
        # A_theta_e_d = np.zeros((N_coeff_nm, N_data))
        # A_phi_e_d = np.zeros((N_coeff_nm, N_data))
        # calculate magnetic field
        B_r_1_tmp = np.dot(m_e_d_Re, A_r_e_d)
        B_theta_1_tmp = np.dot(m_e_d_Re, A_theta_e_dd)
        B_phi_1_tmp = np.dot(m_e_d_Re, A_phi_e_dd)
        B_r_2_tmp = np.dot(m_i_d_Re, A_r_i_d)
        B_theta_2_tmp = np.dot(m_i_d_Re, A_theta_i_dd)
        B_phi_2_tmp = np.dot(m_i_d_Re, A_phi_i_dd)
    # CASE #3: error
    else:
        raise Exception(r"data in both regions (below and above Sq currents)")

    # Rotate into geomagnetic frame
    B_theta_1_gg = np.zeros(N_data)
    B_phi_1_gg = np.zeros(N_data)
    B_theta_2_gg = np.zeros(N_data)
    B_phi_2_gg = np.zeros(N_data)
    for i in range(N_data):
        # get inverse of R
        tmp = R[i].transpose()
        B_theta_1_gg = tmp[0, 0] * B_theta_1_tmp + tmp[0, 1] * B_phi_1_tmp
        B_phi_1_gg = tmp[1, 0] * B_theta_1_tmp + tmp[1, 1] * B_phi_1_tmp
        B_theta_2_gg = tmp[0, 0] * B_theta_2_tmp + tmp[0, 1] * B_phi_2_tmp
        B_phi_2_gg = tmp[1, 0] * B_theta_2_tmp + tmp[1, 1] * B_phi_2_tmp
    # correct for F10.7 dependence
    w = (1 + s['N']*f107)
    B_1 = np.vstack((B_r_1_tmp, B_theta_1_gg, B_phi_1_gg)) * w
    B_2 = np.vstack((B_r_2_tmp, B_theta_2_gg, B_phi_2_gg)) * w
    return B_1, B_2
